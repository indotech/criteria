# Основные

## Модули

### Модули должны подключаться в начале файла
Это правило можно нарушить только на это есть объективные причины,
например условная загрузка или автозагрузка по динамическому пути.

**Правильно:**
```js
const assert = require('assert');
const isString = require('lodash/isString');

function doSomethingStrange(string) {
  assert(isString(string));
}
```
Или условная отложенная загрузка:
```js
function getProvider(name) {
  if (name === 'GridFS') {
    return require('./providers/GridFS');
  } else {
    return require('./providers/Memory');
  }
}
```

**Неправильно:**
```js
const SOME_PARAM = 12;
const isString = require('lodash/isString');
function doSomethingStrange(string) {
  assert(isString(string));
}
const assert = require('assert');
```

### Стандартные модули, например модули из NodeJS, должны подключаться первыми
**Правильно**
```js
const assert = require('assert');
const isString = require('lodash/isString');
```

**Неправильно**
```js
const isString = require('lodash/isString');
const assert = require('assert');
```

### Модули из package.json, bower.json или подобных списков пакетов должны подключаться после стандартных модулей

### Модули проекта должны подключаться последними
**Правильно**
```js
const assert = require('assert');
const isString = require('lodash/isString');

const Memory = require('./providers/Memory.js')
```

**Неправильно**
```js
const isString = require('lodash/isString');
const assert = require('assert');
```

### Константы размещаются после подключения всех модулей

### Действия с переменными модулей должны производиться после подключения всех модулей и описания всех констант
**Правильно**
```js
const util = require('util');
const mail = require('some-mail-module');
const isString = require('lodash/isString');

const SOME_PARAM = 12;

const send = util.promisify(mail.send);
```

**Неправильно**
```js
const util = require('util');
const mail = require('some-mail-module');
const send = util.promisify(mail.send);
const isString = require('lodash/isString');

const SOME_PARAM = 12;
```

### Нельзя подключать модуль несколько раз в одном файле
Это правило можно нарушить только на это есть объективные причины,
например условная загрузка или автозагрузка по динамическому пути.

Вместо множественного подключения нужно использовать присваивание через деструктор.

**Правильно**
```js
const { promisify, inspect } = require('util');
```

**Неправильно**
```js
const promisify = require('util').promisify;
const inspect = require('util').inspect;
```

### Пути до модулей не должны быть динамическими без объективных причин
Это правило можно нарушить только на это есть объективные причины,
например условная загрузка или автозагрузка по динамическому пути.


### Динамические пути строятся через `path.join`
Динамические пути должны быть абсолютными.
Отправной точкой может быть `__dirname`

**Правильно**
```js
function getComponent(name) {
  return require(path.join(__dirname, `../components/${name}.js`));
}
```

**Неправильно**
```js
function getComponent(name) {
  return require(`../components/${name}.js`);
}
```

### При подключении библиотек функций, таких как lodash, должны подключаться отдельные функции, а не вся библиотека целиком
**Правильно**
```js
const isString = require('lodash/isString');
const isFunction = require('lodash/isFunction');
```

**Неправильно**
```js
const { isString, isFunction } = require('lodash');
```

### Экспорт из модулей должен быть в конце файла
**Правильно**
```js
let someVar = null;

function someFunction(value) {
 someVar = value;
};

module.exports = someFunction;
```

**Неправильно**
```js
function someFunction(value) {
 someVar = value;
};

module.exports = someFunction;

let someVar = null;
```

## Зависимости

### В прод-зависимостях находятся только необходимые и используемые модули
Если какой-то модуль не используется в проде, то он должен находится в дев-зависимостях.
Или, например, модуль был удален из кода, из зависимостей его тоже следует удалить.

### В файле пакета указаны все зависимости

### Если модуль является расширением какой-то другой библиотеки, необходимая для работы версия библиотеки должна быть добавлена в `peer`-зависимости вместо прод-зависимостей
Если родительская библиотека нужна для тестов, она добавлятся еще и в дев-зависимости.

**Правильно**
```json
{
  "name": "rubik-some",
  "peerDependencies": {
    "rubik-main": "^1.0.0"
  },
  "devDependencies": {
    "rubik-main": "^1.0.0"
  }
}
```

**Неправильно**
```json
{
  "name": "rubik-some",
  "dependencies": {
    "rubik-main": "^1.0.0"
  }
}
```


# Дополнительные

## Модули

### Динамические пути по возможности должны содержать проверку доступа
Например такую:
```js
const componentNameTest = /^[A-Za-zА-Яа-я][A-Za-zА-Яа-я0-9_]*?$/;

function isNameCorrect(name) {
  if (!(isString(name) && name)) return false;
  return componentNameTest.test(name);
}

function getComponent(name) {
  // Нужно недопустить прохождения потенциально опасных имен с вхождениями:
  // ../, ./, ~/ и т. п.
  if (!isNameCorrect(name)) {
    throw new TypeError('Component\'s name is not secure');
  }
  return require(path.join(__dirname, `../components/${name}.js`));
}
```

## Зависимости

### Количество внешних зависимостей минимизировано
Если какая-то задача решается уже подключенным модулем, не нужно тащить еще один.
Например, если в проекте уже используется `lodash`, не нужно подключать к нему `ramda`.

Если задача легко решается встроенными в язык функциями,
то подключать отдельный модуль не стоит.
Например не нужно подключать `is-array`, вместо этого нужно использовать `Array.isArray`.
