# Основные

## Промисы

### Promise.all используется там где возможно
Если какую-то асинхронную цепочку можно выполнить «параллельно»,
нужно использовать `Promise.all`.

Например, когда нужно запросить данные из нескольких несвязанных коллекций.

### Promise.race используется там где возможно
Например, для таймаутов операций.

### В обертках над callback API вызовы resolve и reject должны быть возвращены
Это позволяет избежать сложных ошибок, например резолва промиса, когда он был зареджекчен.
Или двойного резолва.

**Правильно**
```js
function stopServer() {
  return new Promise((resolve, reject) => {
    return server.stop((err) => {
      if (err) return reject(err);
      return resolve();
    });
  });
}
```

**Неправильно**
```js
function stopServer() {
  return new Promise((resolve, reject) => {
    return server.stop((err) => {
      if (err) reject(err);
      resolve();
    });
  });
}
```

### В обертках над callback API обработка ошибки должна быть описана в самом начале
Серьезно, не стреляйте себе в ногу.

**Правильно**
```js
function stopServer() {
  return new Promise((resolve, reject) => {
    return server.stop((err) => {
      if (err) return reject(err);
      return resolve();
    });
  });
}
```

**Неправильно**
```js
function stopServer() {
  return new Promise((resolve, reject) => {
    return server.stop(() => {
      return resolve();
    });
  });
}
```

```js
function stopServer() {
  return new Promise((resolve, reject) => {
    return server.stop((err) => {
      if (!err) {
        return resolve();
      } else {
        return reject(err);
      }
    });
  });
}
```

### Предполагаемый результат Promise.all не превышает разумных пределов
Если отправить в `Promise.all` много промисов,
которые резолвят много объектов, можно внезапно столкнуться с тем,
что оперативная память доступная процессу кончилась.

Пример может быть такой:
```js
const messages = await Messages.find({}, { _id: 1 }).exec();
const promisses = messages.map((message) => {
  return Bot.find({ _id: message.bot });
});

const results = await Promise.all(promisses);
```
Проблема этого кода в том, что `Promise.all` внутри будет наполнять результирующий массив данными.
Вероятно большим колличеством данных, потому что сообщений может быть много, а боты могут быть большими.

В какой-то момент процесс NodeJS не сможет выделить достаточное колличество оперативной памяти и упадет.

Решений тут несколько. Например пересмотреть подход, и возможно запрашивать данные по другому,
или небольшими партиями.

Как временное решение можно сделать все что нужно в отдельной асинхронной функции (или методе),
и ничего из этой функций не возращать.

```js
const messages = await Messages.find({}, { _id: 1 }).exec();
const promisses = messages.map((message) => dealWithMessage(message));

await Promise.all(promisses);
```

### Цепочки промисов не вложены друг в друга без объективных причин
**Правильно**
```js
Promise.resolve(botId).
then((_id) => {
  return Bot.findOne({ _id });
}).
then((bot) => {
  return User.findOne({ _id: bot.owner });
}).
then((user) => {
  return Receipt.find({ _id: { $in: user.receipts } });
});
```

**Неправильно**
```js
Promise.resolve().
then((_id) => {
  return Bot.findOne({ _id }).
  then((bot) => {
    return User.findOne({ _id: bot.owner }).
    then((user) => {
      return Receipt.find({ _id: { $in: user.receipts } });
    });
  });
});
```

### В основной цепочке промисов обязательно должен быть хотябы один `.catch()`
В цепочке промисов, с которой стартуют вызовы должен быть `.catch()`.
Как пример такой цепочке:
```js
module.exports = (req, res) => {
  readBody(req).
  then((buffer) => {
    return JSON.parse(buffer);
  }).
  then(checkPermissions).
  then(startRPC).
  then((action) => {
    if (!action.type) action.type = 'response';
    return Promise.all([action, promiteLog(action)]);
  }).
  then(([action]) => {
    res.end(JSON.stringify(action));
  }).
  catch((err) => {
    console.error('Route error', err);
    res.end();
  });
}
```

### Если в цепочке один `.catch` он должен быть в ее конце

## Асинхронные функций

### Не используется `return await`
**Правильно**
```js
function someAsyncFunction(a, b) {
  const c = a + b;
  return asyncPow(c, BILLION);
}
```

```js
async function getClientBots(clientId) {
  const client = await Client.findOne({ _id: clientId });
  return Bot.find({ owner: client });
}
```

**Неправильно**
```js
async function someAsyncFunction(a, b) {
  const c = a + b;
  return await asyncPow(c, BILLION);
}
```

```js
async function getClientBots(clientId) {
  const client = await Client.findOne({ _id: clientId });
  return await Bot.find({ owner: client });
}
```

### С большими коллекциями нужно взаимодействовать курсором, если он доступен
**Правильно**
```js
const bots = await Bot.find().cursor();

for await (const bot of bots) {
  dealWithBot(bot);
}
```

**Неправильно**
```js
const bots = await Bot.find().exec();
```

### При выполнении приложения или модуля не возникает необработанных ошибок `Unhandled Promise Rejection`

# Дополнительные

## Промисы

### Используется нативная реализация промисов, кроме случаев когда это объективно оправдано

### В асинхронных функциях и цепочках промисов нет бесполезных или вредных `catch` или `.catch` блоков
Если функция используется в цепочке промисов, или другой асинхронной функцией то ей скорее всего не нужен блок `try/catch` или `.catch()`.
Ошибки нужно обрабатывать в более высоких функциях.

## Асинхронные функций

### Для перебора асинхронных курсоров и итераторов используется цикл `for await of`
```js
const bots = await Bot.find().cursor();

for await (const bot of bots) {
  dealWithBot(bot);
}
```
