# Основные

## Промисы

### Promise.all используется там где возможно
Если какую-то асинхронную цепочку можно выполнить «параллельно»,
нужно использовать `Promise.all`.

Например если нужно запросить данные из нескольких несвязанных коллекций.

### Promise.race используется там где возможно
Например для таймаутов операций.

### В обертках над callback API вызовы resolve и reject должны быть возвращены
Это позволяет избежать сложных ошибок, например резолва промиса, когда он был зареджекчен.
Или двойного резолва.

**Правильно**
```js
function stopServer() {
  return new Promise((resolve, reject) => {
    return server.stop((err) => {
      if (err) return reject(err);
      return resolve();
    });
  });
}
```

**Неправильно**
```js
function stopServer() {
  return new Promise((resolve, reject) => {
    return server.stop((err) => {
      if (err) reject(err);
      resolve();
    });
  });
}
```

### В обертках над callback API обработка ошибки должна быть описана в самом начале
Серьезно, не стреляйте себе в ногу

**Правильно**
```js
function stopServer() {
  return new Promise((resolve, reject) => {
    return server.stop((err) => {
      if (err) return reject(err);
      return resolve();
    });
  });
}
```

**Неправильно**
```js
function stopServer() {
  return new Promise((resolve, reject) => {
    return server.stop(() => {
      return resolve();
    });
  });
}
```

```js
function stopServer() {
  return new Promise((resolve, reject) => {
    return server.stop((err) => {
      if (!err) {
        return resolve();
      } else {
        return reject(err);
      }
    });
  });
}
```

# Дополнительные

## Промисы

### Используется нативная реализация промисов, кроме случаев когда это объективно оправдано
