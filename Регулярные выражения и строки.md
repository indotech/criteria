# Основные

## Регулярные выражения

### Собирать выражение «по кусочкам» можно только с проверенными данными
Проблема в том, что в данных может быть [«злое» регулярное выражение](https://en.wikipedia.org/wiki/ReDoS),
и его выполнение вызовет отказ в обслуживании.

**Правильно**

```js
const name = names.has(req.body.name) ? req.body.name : DEFAULT_NAME;
const regexp = new RegExp('^' + name);
```

**Неправильно**

```js
const regexp = new RegExp('^' + req.body.name);
```

Альтернативой на сервере может быть модуль [`node-re2`](https://github.com/uhop/node-re2)

### Выражения с глобальным флагом не кешируются, если используется метод `.test`
Малоизвестная особенность метода `.test` у регулярных выражений:

Когда у выражения есть флаг `g` — глобальный поиск
— `.test` ищет первое вхождение, и следующий поиск начнется
не по всей строке, а от индекса этого вхождения.

Подробности в статье [про RegExp.prototype.test на MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/test#Using_test_on_a_regex_with_the_global_flag)

**Правильно**

```js
function check(text) {
  return /a/g.test(text);
}
```

**Неправильно**
```js
const regexp = /a/g;

function check(text) {
  return regexp.test(text);
}
```

Поиграться с проблемой довольно просто:
```js
const regexp = /a/g;
regexp.test('abab'); // true
regexp.test('abab'); // true
regexp.test('abab'); // false
```

### Выражение проверено на коллизии
Иногда кажется что регулярное выражение написано правильно.
И небольшие тесты это подтверждают, но нужно проверить еще
и коллизии.

Например выражение может не учитывать начало и конец строки, когда нужно.

**Правильно**
```js
// Супер простая проверка на email
// @ есть, она одна и не с краю
/^[^@]+?@[^@]+?$/.test('test@example.com'); // true
/^[^@]+?@[^@]+?$/.test('test.example.com'); // false
/^[^@]+?@[^@]+?$/.test('test@example@com'); // false
```

**Неправильно**
```js
// Супер простая проверка на email
// @ есть, она одна и не с краю
/[^@]+?@[^@]+?$/.test('test@example.com'); // true
/[^@]+?@[^@]+?$/.test('test.example.com'); // false
// упс
/[^@]+?@[^@]+?$/.test('test@example@com'); // true
```

## Строки

### Используется нативный `.trim`, `.trimEnd`, `.trimStart`, `.padEnd`, `.padStart`
Вместо сторонних библиотек.
Обратная совместимость со старыми версиями JS может потребовать нарушить это правило.

### Не используются «теговые» методы у строк
Например `.bold` нельзя использовать, `.small`, `.strike` и т. п.

### Наличие подстроки проверяется через `.includes`, вместо `.search`
`.includes` возвращает сразу `true` или `false`, а индекс из `.search` нужно еще сравнить или инвертировать.
Это правило неприменимо, если ниже индекс все же понадобится.

**Правильно**
```js
function check(connect) {
  if (!connect.includes('@')) {
    throw new Error('Invalid connect address');
  }
}
```
или так, если индекс понадобится ниже.
Использовать и `.includes` и `.search` не нужно.
```js
function getUser(connect) {
  const index = connect.search('@');
  if (!~index) {
    throw new Error('Invalid connect address');
  }

  return connect.slice(0, index);
}
```

**Неправильно**
```js
function check(connect) {
  if (connect.search('@') === -1) {
    throw new Error('Invalid connect address');
  }
}
```
или с инвертированием
```js
function check(connect) {
  if (!~connect.search('@')) {
    throw new Error('Invalid connect address');
  }
}
```
или и `.includes` и `.search`.
Терпимо, но двойной проход по строке неприятен.
```js
function getUser(connect) {
  if (!connect.includes('@')) {
    throw new Error('Invalid connect address');
  }

  return connect.slice(0, connect.search('@'));
}
```

# Дополнительные

## Регулярные выражения

### Везде используется литеральная запись, вместо конструктора
Читать `/a/g` проще чем `new RegExp('a', 'g')`

### Выражения кешируются в разумных пределах
Например, если мы уверены, что функция проверки или валидации
будет выполнена множество раз и относительно часто.

## Строки

### Когда есть локаль, для строк вызваны `.toLocaleLowerCase` и `.toLocaleUpperCase` вместо `.toLowerCase` и `toUpperCase` соответственно
Нужно чтобы избежать казусов с некоторыми языками.

### Использована строка вместо регулярного выражения там, где это возможно
Например в методе `.search`

**Правильно**
```js
'abracadabra'.search('a');
```

**Неправильно**
```js
'abracadabra'.search(/a/);
```

