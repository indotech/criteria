# Основные

## Функции и методы

### Код вызова разнесен на несколько строк, если он занимает больше 90 символов строке или если его сложно прочесть
**Правильно**
```js
callSomeFunctionWithReallyDirtyLongName(
  andReallyDirty, andLongArguments, hardToReadAndWrite, ohOhOh
);
```
или
```js
callSomeFunctionWithReallyDirtyLongName(
  andReallyDirty,
  andLongArguments,
  hardToReadAndWrite,
  ohOhOh
);
```

**Неправильно**
```js
callSomeFunctionWithReallyDirtyLongName(andReallyDirty, andLongArguments, hardToReadAndWrite, ohOhOh);
```

В идеале такие места лучше изменить, переделать, перерефакторить.
Сделать что угодно, чтобы стало кроче, лаконичней и опрятней.

### Фукции и методы стремятся к одному уровню ответственности
Давайте разберем на примере.
Допустим у вас есть функция, которая читает с диска, парсит и создает компоненты из YAML файлов:
```js
const componentNameTest = /^[A-Za-zА-Яа-я][A-Za-zА-Яа-я0-9_]*?$/;

async function getComponent(name) {
  // Проверяем имя
  assert(isString(name) && name && componentNameTest.test(name));
  // Читаем yaml
  const content = await fs.readFile(path.join(__dirname, `./components/${name}.yaml`));
  // Проверяем, что контент компонента есть
  assert(!!content);
  const raw = yaml.parse(content);
  // Проверяем, что компонент валидный
  assert(raw.name && raw.props && raw.name === name && Components[name]);
  const Component = Components[name];

  return new Component(raw);
}
```
Кажется фукнция небольшая, с ней все в порядке. Но на самом деле она работает на разных уровнях ответсвенности.

В ней написана и логика проверки имени компонента, и логика чтения с диска, и парсинг из yaml, и еще куча всего.
На самом деле можно разделить функцию на несколько, и сильно упростить:
```js
function isComponentName(name) {
  return isString(name)
    && name
    && componentNameTest.test(name);
}

function getComponentClass(name) {
  return Components[name] || null;
}

function isComponentValid(name, raw) {
  return raw.name
    && raw.props
    && raw.name === name
    && getComponentClass(name);
}

function readComponent(name) {
  return fs.readFile(
    path.join(__dirname, `./components/${name}.yaml`)
  );
}

async function getRawComponent(name) {
  const content = await readComponent(name);
  try {
    assert(!!content);
    const raw = yaml.parse(content);
    assert(isComponentValid(name, raw));
    return raw;
  } catch(err) {
    throw new ComponentError(ComponentError.PARSE_ERROR);
  }
}

async function getComponent(name) {
  const raw = await getRawComponent(name);
  const Component = getComponentClass(name);
  return new Component(raw);
}
```
Может показаться что функций стало слишком много.
Но такие функции проще читать, проще тестировать автоматически, и их проще обслуживать.
Каждая из закрывает разные уровни, в результате итоговая функция лишена лишних подробностей.

Ей больше не важно как вообще имя преобразуется в объект опций компонента, где они хранятся, и в каком формате.
Где находятся конструкторы компонентов ей тоже не важно.
Код получился семантичный и простой для чтения, можно без проблем посмотреть общую картину,
а можно опуститься до частных деталей реализации, если это нужно.

И да, некоторые из обслуживающих функций могут быть разделены на еще более мелкие. А могут быть и объединены в одну.

### Модульные функции — именованные. Они объявлены через `function`
Это такие фукнции которые кладутся в отдельный модуль в `lib`, и в целом относительно независимы.

**Правильно**
```js
module.exports = function checkEngine(engine) {
  assert(!!engine.errors.length);
}
```

**Неправильно**
```js
module.exports = (engine) => {
  assert(!!engine.errors.length);
};
```
или
```js
module.exports = function(engine) {
  assert(!!engine.errors.length);
};
```
Такие функции гораздо проще искать. У них есть имя в стектрейсе ошибок.

# Дополнительные

## Функции и методы

### Если у функции или метода больше трех аргументов, то они перенесены в объект. Внутри аргументов функции использован деструктор
Это нужно, чтобы в будущем упростить вызов по памяти.
У аргументов появятся имена, их можно будет менять местами и готовить заранее.

Пример ниже:
**Было**
```js
function doSomething(one, two, three, four) {
  du(one);
  duHast(one, two);
  duHastEtwas(one, two, three);
  duHastEtwasUnrecht(one, two, three, four);
}
doSomething(1, 2, 3, 4);
```
**Стало**
```js
function doSomething({ one, two, three, four }) {
  du(one);
  duHast(one, two);
  duHastEtwas(one, two, three, four);
  duHastEtwasUnrecht(one, two, three, four);
}

doSomething({ one: 1, two: 2, three: 3, four: 4 });
```
Такой вызов длинней, но проще поддается модификациям, и его просто запомнить, так как больше не зависит от порядка аргументов.

### Стрелочные функции применяются там где это уместно
Уместно:
- в колбэках
- обработчиках событий, если стрелочная функция не метод объекта класса
- там где нужно удержать контекст
- там где нужно удержать аргументы
- в создаваемых и возвращаемых функциях
- если важно ограничить вызов фунцкии до ее инициализации

Не уместно:
- для библиотечных или модульных функций
- «они мне нравятся больше чем просто функции»

Просто нужно знать свой язык, и понимать, что стрелочные функции — не просто красивая обертка.

### Простые анонимные функции применяются там где это уместно
Например когда нужно передать контекстно-независимую функцию или важно ограничить вызов фунцкии до ее инициализации.
```js
Model.method('', function() {});
```
Хотя в таких случаях часто имеет смысл использовать функции с именем (например в моделях Mongoose),
чтобы ее можно было быстро найти инструментами редактора по имени.
